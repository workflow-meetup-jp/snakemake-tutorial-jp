この記事は[Workflow Advent Calendar 2020](https://adventar.org/calendars/5339)の4日目の記事です。
4日に分けて[Snakemake Tutorial](https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html)を和訳します。
これはその4日のうちの第2日目です。

# Basics: An example workflow
Please make sure that you have **activated** the environment we created before, and that you have an open terminal in the working directory you have created.
以前に作成した環境を**アクティブ化**したこと、加えて作成した作業ディレクトリでターミナルを開いていることを確認してください。

**A Snakemake workflow is defined by specifying rules in a Snakefile.**
**Rules decompose the workflow into small steps** (e.g., the application of a single tool) by specifying how to create sets of **output files** from sets of **input files.**
Snakemake automatically **determines the dependencies** between the rules by matching file names.

**Snakemake のワークフローは、Snakefile 中でルールを指定することによって定義されます。**
ルールは、**入力ファイル**のセットから**出力ファイル**のセットを作成する方法を指定することにより、**ワークフローを小さなステップ** (例えば、一つのツールだけから成るアプリケーション) **に分解します。**
Snakemakeは、ファイル名を照合することにより、ルール間の**依存関係を**自動的に**判別します**。

The Snakemake language extends the Python language, adding syntactic structures for rule definition and additional controls.
All added syntactic structures begin with a keyword followed by a code block that is either in the same line or indented and consisting of multiple lines.
The resulting syntax resembles that of original Python constructs.

Snakemake 言語は Python 言語を拡張し、ルール定義と追加のコントロールの構文構造を追加します。
追加されたすべての構文構造は、キーワードで始まり、同じ行にあるか、インデントされて複数の行で構成されるコードブロックが続きます。
結果の構文は、元の Python 構造の構文に似ています。

In the following, we will introduce the Snakemake syntax by creating an example workflow.
The workflow comes from the domain of genome analysis.
It maps sequencing reads to a reference genome and call variants on the mapped reads.
The tutorial does not require you to know what this is about.
Nevertheless, we provide some background in the following paragraph.

以下では、例のワークフローを作成することで Snakemake の構文を紹介します。
ワークフローは、ゲノム分析分野由来のものです。
シーケンシングリードをリファレンスゲノムにマップし、マップされたリードの変異を検出します。
チュートリアルでは、これが何であるかを知っている必要はありません。
とは言っても、次の段落でいくつかの背景を説明します。

## Background
The genome of a living organism encodes its hereditary information.
It serves as a blueprint for proteins, which form living cells, carry information and drive chemical reactions.
Differences between populations, species, cancer cells and healthy tissue, as well as syndromes or diseases can be reflected and sometimes caused by changes in the genome.
This makes the genome a major target of biological and medical research.
Today, it is often analyzed with DNA sequencing, producing gigabytes of data from a single biological sample (e.g. a biopsy of some tissue).
For technical reasons, DNA sequencing cuts the DNA of a sample into millions of small pieces, called **reads.**
In order to recover the genome of the sample, one has to map these reads against a known **reference genome** (e.g., the human one obtained during the famous [human genome project](https://en.wikipedia.org/wiki/Human_Genome_Project)).
This task is called read mapping.
Often, it is of interest where an individual genome is different from the species-wide consensus represented with the reference genome.
Such differences are called variants.
They are responsible for harmless individual differences (like eye color), but can also cause diseases like cancer.
By investigating the differences between the all mapped reads and the reference sequence at one position, variants can be detected.
This is a statistical challenge, because they have to be distinguished from artifacts generated by the sequencing process.

生物のゲノムは、その遺伝情報をコード化しています。
これは、生体細胞を形成し、情報を伝達し、化学反応を促進するタンパク質の青写真として機能します。
集団、種、癌細胞、健康な組織の違い、さらには症候群や病気が、ゲノムに反映され、またその変化によって引き起こされることもあります。
これにより、ゲノムは生物学的および医学的研究の主要なターゲットになります。
現代では、それはしばしばDNAシーケンシングで分析され、単一の生物学的サンプル(例えば、いくつかの組織の生検)からギガバイトのデータを生成します。
技術的な理由から、DNAシーケンシングはサンプルのDNAを**リード**と呼ばれる数百万の小さな断片に切断します。
サンプルのゲノムを回復するには、これらの読み取りを既知のリファレンスゲノム（たとえば、有名なヒトゲノムプロジェクト中に取得されたヒトゲノム）に対してマッピングする必要があります。

## Step 1: Mapping reads
Our first Snakemake rule maps reads of a given sample to a given reference genome (see [Background](https://snakemake.readthedocs.io/en/stable/tutorial/basics.html#tutorial-background)).
For this, we will use the tool [bwa](http://bio-bwa.sourceforge.net/), specifically the subcommand `bwa mem`.
In the working directory, **create a new file** called `Snakefile` with an editor of your choice.
We propose to use the [Atom](https://atom.io/) editor, since it provides out-of-the-box syntax highlighting for Snakemake.
In the Snakefile, define the following rule:

最初のSnakemakeルールは、与えられたサンプルの読み取りを与えられたリファレンスゲノムにマッピングします ([背景](https://snakemake.readthedocs.io/en/stable/tutorial/basics.html#tutorial-background)を参照)。
このために、ツール [bwa](http://bio-bwa.sourceforge.net/)、特にサブコマンド `bwa mem`を使用します。
作業ディレクトリに、好きなエディタを使用して`Snakefile`という**新しいファイルを作成**します。
[Atom](https://atom.io/)エディターを使うことを提案します。AtomはSnakemakeのためのすぐに使えるシンタックスハイライトを提供しているためです。
Snakefileで、次のルールを定義しましょう:

```
rule bwa_map:
    input:
        "data/genome.fa",
        "data/samples/A.fastq"
    output:
        "mapped_reads/A.bam"
    shell:
        "bwa mem {input} | samtools view -Sb - > {output}"
```

> ### Note
> A common error is to forget the comma between the input or output items.
> Since Python concatenates subsequent strings, this can lead to unexpected behavior.
> よくあるエラーは、入力項目または出力項目の間のコンマを忘れることです。
> Pythonは後続の文字列を連結するため、これにより予期しない動作が発生する可能性があります。

A Snakemake rule has a name (here `bwa_map`) and a number of directives, here `input`, `output` and `shell`.
Snakemakeルールには、名前 (ここでは `bwa_map`) といくつかのディレクティブ、ここでは`input`、`output`、そして`shell`があります。
The `input` and `output` directives are followed by lists of files that are expected to be used or created by the rule.
`input`と`output`のディレクティブの後には、ルールによって使用または作成されることが予想されるファイルのリストが続きます。
In the simplest case, these are just explicit Python strings.
最も単純なケースでは、これらは単なる明示的なPythonの文字列です。
The `shell` directive is followed by a Python string containing the shell command to execute.
`shell`ディレクティブの後には、実行するシェルコマンドを含むPython文字列が続きます。
In the shell command string, we can refer to elements of the rule via braces notation (similar to the Python format function).
シェルコマンド文字列では、中括弧表記を使用してルールの要素を参照できます（Python形式の関数と同様）。
Here, we refer to the output file by specifying `{output}` and to the input files by specifying `{input}`.
ここでは、`{output}`を指定して出力ファイルを参照し、`{input}`を指定して入力ファイルを参照します。
Since the rule has multiple input files, Snakemake will concatenate them separated by a whitespace.
ルールには複数の入力ファイルがあるので、Snakemakeはそれらを空白で区切って連結します。
In other words, Snakemake will replace `{input}` with `data/genome.fa data/samples/A.fastq` before executing the command.
つまり、Snakemakeは、コマンドを実行する前に、`{input}`を`data/genome.fa data/samples/A.fastq`に置き換えます。
The shell command invokes `bwa mem` with reference genome and reads, and pipes the output into `samtools` which creates a compressed [BAM](https://en.wikipedia.org/wiki/Binary_Alignment_Map) file containing the alignments.
shellコマンドは、リファレンスゲノムとリードを使用して`bwa mem`を呼び出し、出力を`samtools`にパイプして、アライメントを含む圧縮[BAM](https://en.wikipedia.org/wiki/Binary_Alignment_Map)ファイルを作成します。
The output of `samtools` is piped into the output file defined by the rule.
`samtools`の出力は、ルールで定義された出力ファイルにパイプされます。

When a workflow is executed, Snakemake tries to generate given **target** files.
ワークフローが実行されると、Snakemakeは指定された**ターゲット**ファイルを生成しようとします。
Target files can be specified via the command line. 
ターゲットファイルは、コマンドラインから指定できます。
By executing

```
$ snakemake -np mapped_reads/A.bam
```

in the working directory containing the Snakefile, we tell Snakemake to generate the target file `mapped_reads/A.bam`.
Since we used the `-n` (or `--dry-run`) flag, Snakemake will only show the execution plan instead of actually perform the steps.
The `-p` flag instructs Snakemake to also print the resulting shell command for illustration.
To generate the target files, **Snakemake applies the rules given in the Snakefile in a top-down way.**
The application of a rule to generate a set of output files is called **job**.
For each input file of a job, Snakemake again (i.e. recursively) determines rules that can be applied to generate it.
This yields a [directed acyclic graph (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) of jobs where the edges represent dependencies.
So far, we only have a single rule, and the DAG of jobs consists of a single node.
Nevertheless, we can **execute our workflow** with

上記をSnakefileを含むワーキングディレクトリで実行することで、Snakemakeにターゲットファイル`mapped_reads/A.bam`を生成するように指示します。
`-n` (または `--dry-run`) フラグを使用したため、Snakemakeは実際に手順を実行せず、実行プランのみを表示します。
`-p`フラグは、説明のために結果のシェルコマンドも出力するようにSnakemakeに指示します。
ターゲットファイルを生成するために、**SnakemakeはSnakefileで指定されたルールをトップダウン方式で適用します。**
出力ファイルのセットを生成するためのルールの適用は、**ジョブ**と呼ばれます。
ジョブの入力ファイルごとに、Snakemakeは、ジョブを生成するために適用できるルールを繰り返し（つまり再帰的に）見つけ出します。
これにより、エッジが依存関係を表すジョブの[有向非巡回グラフ（DAG）](https://en.wikipedia.org/wiki/Directed_acyclic_graph)が生成されます。
今のところ、ルールは1つしかなく、ジョブのDAGは単一のノードで構成されています。
それでも、次のように**ワークフローを実行**できます。

```
$ snakemake --cores 1 mapped_reads/A.bam
```

Whenever executing a workflow, you need to specify the number of cores to use.
For this tutorial, we will use a single core for now.
Later you will see how parallelization works.
Note that, after completion of above command, Snakemake will not try to create `mapped_reads/A.bam` again, because it is already present in the file system.
Snakemake **only re-runs jobs if one of the input files is newer than one of the output files or one of the input files will be updated by another job.**

ワークフローを実行するときは常に、使用するコアの数を指定する必要があります。
このチュートリアルでは、ここではシングルコアを使用します。
後で、並列化がどのように機能するか分かるでしょう。
上記のコマンドの完了後、Snakemakeは `mapped_reads/A.bam` を再度作成しようとしないことに注意してください。これは、ファイルシステムにすでに存在しているためです。
Snakemakeは、**入力ファイルの1つが出力ファイルの1つよりも新しい場合、または入力ファイルの1つが別のジョブによって更新される場合にのみ、ジョブを再実行します。**

## Step 2: Generalizing the read mapping rule
Obviously, the rule will only work for a single sample with reads in the file `data/samples/A.fastq`.
However, Snakemake allows to **generalize rules by using named wildcards**.
Simply replace the `A` in the second input file and in the output file with the wildcard `{sample}`, leading to

明らかに、このルールは、ファイル `data/samples/A.fastq` を読み取る単一のサンプルに対してのみ機能します。
ただし、Snakemakeでは、**名前付きワイルドカードを使用してルールを一般化**できます。
2番目の入力ファイルと出力ファイルのAをワイルドカード `{sample}` に単に置き換えると、次のようになります。

```python
rule bwa_map:
    input:
        "data/genome.fa",
        "data/samples/{sample}.fastq"
    output:
        "mapped_reads/{sample}.bam"
    shell:
        "bwa mem {input} | samtools view -Sb - > {output}"
```

> ### Note
> Note that if a rule has multiple output files, Snakemake requires them to all have exactly the same wildcards.
> Otherwise, it could happen that two jobs from the same rule want to write the same file.
> あるルールに複数の出力ファイルがある場合、Snakemakeではそれらすべてがまったく同じワイルドカードを持つ必要があることに注意してください。
> そうしないと、同じルールの2つのジョブが同じファイルを書き込もうとする場合があります。

When Snakemake determines that this rule can be applied to generate a target file by replacing the wildcard `{sample}` in the output file with an appropriate value, it will propagate that value to all occurrences of `{sample}` in the input files and thereby determine the necessary input for the resulting job.
Note that you can have multiple wildcards in your file paths, however, to avoid conflicts with other jobs of the same rule, **all output files** of a rule have to **contain exactly the same wildcards**.

Snakemakeは、出力ファイルのワイルドカード{sample}を適切な値に置き換えることにより、このルールを適用してターゲットファイルを生成できると判断すると、その値を入力ファイル内の{sample}のすべての出現に伝播させ、それによって結果のジョブに必要な入力を決定します。
ファイルパスに複数のワイルドカードを含めることができますが、同じルールの他のジョブとの競合を避けるために、あるルールの**すべての出力ファイル**は**まったく同じワイルドカードを含む**必要があることに注意してください。

When executing
下記を実行すると、

```
$ snakemake -np mapped_reads/B.bam
```

Snakemake will determine that the rule `bwa_map` can be applied to generate the target file by replacing the wildcard `{sample}` with the value `B`.
In the output of the dry-run, you will see how the wildcard value is propagated to the input files and all filenames in the shell command.
You can also **specify multiple targets**, e.g.:

Snakemakeは、ワイルドカード`{sample}`を値`B`に置き換えることにより、ルール`bwa_map`を適用してターゲットファイルを生成できると判断します。
dry-runの出力では、ワイルドカード値が入力ファイルとシェルコマンドのすべてのファイル名にどのように伝播されるかがわかります。
**複数のターゲットを指定する**こともできます、例えば:

```
$ snakemake -np mapped_reads/A.bam mapped_reads/B.bam
```

Some [Bash](https://www.tldp.org/LDP/Bash-Beginners-Guide/html) magic can make this particularly handy.
For example, you can alternatively compose our multiple targets in a single pass via

いくつかの[Bash](https://www.tldp.org/LDP/Bash-Beginners-Guide/html)マジックは、これを特に便利にすることができます。
たとえば、先の別法として、下記の1回のパスで複数のターゲットを作成することができます。

```
$ snakemake -np mapped_reads/{A,B}.bam
```

Note that this is not a special Snakemake syntax.
Bash is just expanding the given path into two, one for each element of the set `{A,B}`.

これは特別なSnakemake構文ではないことに注意してください。
Bashは、指定されたパスを2つに拡張しています。1つはセット`{A、B}`の各要素に対応しています。

In both cases, you will see that Snakemake only proposes to create the output file `mapped_reads/B.bam`.
This is because you already executed the workflow before (see the previous step) and no input file is newer than the output file `mapped_reads/A.bam`.
You can update the file modification date of the input file `data/samples/A.fastq` via

どちらの場合も、Snakemakeが出力ファイル `mapped_reads/B.bam` の作成のみを提案していることがわかります。
これは、以前にワークフローを実行済みであり（前の手順を参照）、出力ファイル `mapped_reads/A.bam` よりも新しい入力ファイルがないためです。
入力ファイル `data/samples/A.fastq` のファイル変更日は、次の方法で更新できます。

```
$ touch data/samples/A.fastq
```

and see how Snakemake wants to re-run the job to create the file `mapped_reads/A.bam` by executing

下記を実行することで、どのようにSnakemakeがジョブを再実行し、ファイル `mapped_reads/A.bam` を作ろうとするかがわかります。

```
$ snakemake -np mapped_reads/A.bam mapped_reads/B.bam
```

## Step 3: Sorting read alignments

For later steps, we need the read alignments in the BAM files to be sorted.
This can be achieved with the [samtools](https://www.htslib.org/) command.
We add the following rule beneath the `bwa_map` rule:

後の手順では、BAMファイル中のリードアライメントをソートする必要があります。
これは、[samtools](https://www.htslib.org/)コマンドで実現できます。
`bwa_map` ルールの下に次のルールを追加します。

```python
rule samtools_sort:
    input:
        "mapped_reads/{sample}.bam"
    output:
        "sorted_reads/{sample}.bam"
    shell:
        "samtools sort -T sorted_reads/{wildcards.sample} "
        "-O bam {input} > {output}"
```

> ### Note
> 
> It is best practice to have subsequent steps of a workflow in separate, unique, output folders.
> This keeps the working directory structured.
> Further, such unique prefixes allow Snakemake to prune the search space for dependencies.
> 
> ワークフローの後続のステップは、個別の、一意の、出力フォルダーに入れるのがベストプラクティスです。
> これにより、構造化された作業ディレクトリが保たれます。
> さらに、このような一意のプレフィックスにより、Snakemakeは依存関係の検索スペースを削除できます。

This rule will take the input file from the `mapped_reads` directory and store a sorted version in the `sorted_reads` directory.
Note that Snakemake **automatically creates missing directories** before jobs are executed.
For sorting, `samtools` requires a prefix specified with the flag `-T`.
Here, we need the value of the wildcard `sample`.
Snakemake allows to access wildcards in the shell command via the `wildcards` object that has an attribute with the value for each wildcard.

このルールは、 `mapped_reads` ディレクトリから入力ファイルを取得し、ソートされたバージョンを `sorted_reads` ディレクトリに保存します。
Snakemakeは、ジョブが実行される前に、**見当たらないディレクトリを自動的に作成する**ことに注意してください。
ソートのために、`samtools` にはフラグ `-T`で指定されるプレフィックスが必要です。
ここでは、ワイルドカード `sample` の値が必要です。
Snakemakeを使用すると、各ワイルドカードに対する値を持つ特性を備えた `wildcards` オブジェクトを介して、シェルコマンド中でワイルドカードにアクセスできます。

When issuing

下記コマンドを実行すると

```
$ snakemake -np sorted_reads/B.bam
```

you will see how Snakemake wants to run first the rule `bwa_map` and then the rule `samtools_sort` to create the desired target file: as mentioned before, the dependencies are resolved automatically by matching file names.

Snakemakeがどのように最初にルール `bwa_map` を実行し、次にルール `samtools_sort` を実行して、目的のターゲットファイルを作成する方法がわかるでしょう: 前述のように、依存関係はファイル名を照合することで自動的に解決されます。

## Step 4: Indexing read alignments and visualizing the DAG of jobs

Next, we need to use samtools again to index the sorted read alignments for random access.

次に、samtoolsを再度使用して、ランダムアクセス用にソートされた読み取りアライメントにインデックスを付ける必要があります。

This can be done with the following rule:

これは、次のルールで実行できます:

```python
rule samtools_index:
    input:
        "sorted_reads/{sample}.bam"
    output:
        "sorted_reads/{sample}.bam.bai"
    shell:
        "samtools index {input}"
```

> ### Note
> 
> Snakemake uses the Python format mini language to format shell commands.
> Sometimes you have to use braces for something else in a shell command.
> In that case, you have to escape them by doubling, e.g.,
> ``ls {{A,B}}.txt``.
> 
> Snakemakeは、Python形式のミニ言語を使用してシェルコマンドをフォーマットします。
> シェルコマンドで他の何かに中括弧を使用しなければならない場合があります。
> その場合、中括弧を二重にしてそれらを回避する必要があります。
> 例えば ``ls {{A,B}}.txt``。

Having three steps already, it is a good time to take a closer look at the resulting DAG of jobs. By executing

すでに3つのステップがあるので、結果として得られるジョブのDAGを詳しく調べる良い機会です。下記を実行するとDAGができます。

```
$ snakemake --dag sorted_reads/{A,B}.bam.bai | dot -Tsvg > dag.svg
```

